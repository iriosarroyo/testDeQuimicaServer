import { ListUsersResult } from "firebase-admin/auth";
import { Topics } from "../interfaces/firebase";
import { Group, UserDDBB } from "../interfaces/users";
import { inAdmin, pushAdmin, queryChildEqualToMain, readAdmin, readAdminCache, readMain, readMainCache, writeAdmin } from "./DDBB";
import { mainAuth, mainMsg } from "./firebaseConfig";
import nodemailer from 'nodemailer'
import { config } from 'dotenv';
import { Socket } from "socket.io";
import { globalSocket } from "../socket";
config()

const subscribeToTopic = (token:string|string[], topic:Topics) =>{
    return mainMsg.subscribeToTopic(token, topic);
}

const updateAllTokens = async () =>{
    const [tokens] = await readAdmin("messaging/tokens") as [{[key:string]:{topics:string}}|undefined, Error|undefined];
    const initVal:{[k:string]:string[]} = {};
    if(tokens === undefined) return;
    const tokensByTopic = Object.entries(tokens).reduce((prevValue, [token, tokenInfo]:[string,{topics:string}]) => {
        const {topics} = tokenInfo;
        const allTopics = topics.split(";");
        allTopics.forEach(top => {
            prevValue[top] ??= [];
            prevValue[top].push(token)
        })
        return prevValue;
    }, initVal)
    Object.entries(tokensByTopic).forEach(([topic, tokens]) =>{
        mainMsg.unsubscribeFromTopic(tokens, topic).then((response) =>{
            const {errors} =response;
            errors.sort((a,b) => b.index - a.index)
            errors.forEach((err) =>{
                const { error, index} =err
                if(error.code !== "UNREGISTERED" && error.code !== "INVALID_ARGUMENT") return;
                writeAdmin(`messaging/tokens/${tokensByTopic[topic][index]}`, null)
                tokensByTopic[topic].splice(index);
            })
        })
        mainMsg.subscribeToTopic(tokensByTopic[topic], topic);
    });
}   

const A_MONTH = 30 * 24 * 3600000
export const manageToken = async (uid:string, token:string, topics:Topics[]) =>{
    const path = `messaging/tokens/${token}`;
    const path2 = `notifications/tokens/${uid}/${token}`
    writeAdmin(path2, true)
    const isInAdmin = (await inAdmin(path))[0]
    if(!isInAdmin) await writeAdmin(path, { topics: topics.join(";")});
    if((((await readAdmin('messaging/lastUpdate'))[0] ?? 0) +  A_MONTH )< Date.now()){
        await updateAllTokens();
        await writeAdmin('messaging/lastUpdate', Date.now())
    }else if(!isInAdmin){
        await Promise.all(topics.map(topic => subscribeToTopic(token, topic)))
    }

}

 
export const sendNotification = (title:string, body:string, topic:Topics) =>{
    return mainMsg.sendAll([
        {
            topic,
            notification:{
                title,
                body,
            }
        }
    ])

}
let dict_cache:{[k:string]:string|undefined};
let cache_timeout:number = 0
const getUsersDict = async () =>{
    if(cache_timeout > Date.now() && dict_cache) return dict_cache
    const usersAuth = await mainAuth.listUsers();
    const dict:{[k:string]:string|undefined} = {}
    usersAuth.users.forEach(({uid, email}) => { dict[uid] = email})
    dict_cache = dict
    cache_timeout = Date.now() + 15 * 60 * 1000 // 15 minutes
    return dict
}

const getNotificationDataFromUser = ([uid, user]:[string, UserDDBB], listUsers: {[k:string]:string|undefined}) =>{
    const {name, surname} = user
    const email = listUsers[uid]
    return {completeName: `${name} ${surname}`, uid, email}
}

export const getGroupByDBProp = async (prop:string, value: any, secondProp?:any) =>{
    const promises = [
        queryChildEqualToMain('users', prop, value, secondProp),
        getUsersDict(),
    ] as const
    const [usersRead, dict] = await Promise.all(promises);
    const [users]:[{[k:string]:UserDDBB}, Error|undefined] = usersRead
    return Object.entries(users ?? {}).map(x => getNotificationDataFromUser(x, dict))
} 

export const getGroupAllUsers = async () => {
    const promises = [
        readMainCache('users'),
        getUsersDict(),
    ] as const
    const [usersRead, dict] = await Promise.all(promises);
    const [users]:[{[k:string]:UserDDBB}, Error|undefined] = usersRead
    //An array for the flat
    return {
        id: 'autogenerated_all_users',
        name: 'Todos los usuarios',
        disabled: true,
        people: Object.entries(users ?? {}).map(x => getNotificationDataFromUser(x, dict))
    }
}

export const getGroupsFromDB = async () => {
    const promises = [
        readAdmin('groups'),
        readMainCache('users'),
        getUsersDict(),
    ] as const
    const [adminRead, mainRead, dict] = await Promise.all(promises)
    const [groups]:[{[k:string]:Group},Error|undefined] = adminRead
    const [users]:[{[k:string]:UserDDBB}, Error|undefined] = mainRead
    return Object.entries(groups ?? {}).map(([id, group]) => ({
        id, 
        ...group, 
        people: Object.entries(group.people ?? {}).map(([uid, email]) => {
            if(typeof email === "string") return {email, uid}
            return getNotificationDataFromUser([uid, users[uid]], dict)
        })
    }))
}

export const createGroup = async (name:string) => {
   const [ref] = await pushAdmin('groups', {name})
   return ref?.key
}

export const copyGroup = async (name:string, people:{[k:string]:string|boolean}) => {
   const [ref] = await pushAdmin('groups', {name, people})
   return ref?.key
}

export const deleteGroup = async (id:string) => {
    const err = await writeAdmin(`groups/${id}`, null)
    return err === undefined
}

export const renameGroup = async (id:string, newName:string) => {
    const err = await writeAdmin(`groups/${id}/name`, newName)
    return err === undefined
}

export const addPersonToGroup = async (id:string, uid:string, isEmail?:boolean) =>{
    if(!isEmail){
        const err = await writeAdmin(`groups/${id}/people/${uid}`, true)
        return err === undefined
    }
    const [ref] = await pushAdmin(`groups/${id}/people`, uid)
    return ref?.key
}

export const removePersonFromGroup = async (id:string, uid:string) =>{
    const err = await writeAdmin(`groups/${id}/people/${uid}`, null)
    return err === undefined
}

const CURSOS = {
    eso3: "3ยบ ESO",
    eso4: "4ยบ ESO",
    bach1: "1ยบ bach",
    bach2: "2ยบ bach"
}


// Remains group with all users
export const getAllGroups = async () => {
    const rnd = Math.random()
    console.time("timing" + rnd)
    const res = await Promise.all([
        getGroupAllUsers(),
        Promise.all(Object.entries(CURSOS).map(async([id, name]) =>({
            people: await getGroupByDBProp('year', id),
            disabled: true,
            name,
            id: `autogenerated_${id}`,
        }))),
        Promise.all(Array(2).fill(null).map(async (_, i) =>({
            name: i === 0 ? 'Admins' : 'No admins',
            disabled: true,
            id: `autogenerated_admin_${i === 0}`,
            people: await (i === 0 ? getGroupByDBProp('admin', true) : getGroupByDBProp('admin', null, false))
        }))),
        Promise.all(Array(1).fill(null).map(async (_, i) =>({
            name: 'Editores',
            disabled: true,
            id: `autogenerated_editor`,
            people: await getGroupByDBProp('editor', true)
        }))),
        getGroupsFromDB(),
    ])
    console.timeEnd("timing" + rnd)
    return res.flat(1)
}

const transporter = nodemailer.createTransport({
    service: 'gmail',
    auth: {
        user: process.env.email,
        pass: process.env.password
    }
})
export const sendEmail = (emails:string|string[], subject:string, html:string) =>{
    return transporter.sendMail({
        from: process.env.email ,
        bcc: emails,
        html, subject
    })
}

let timeout: NodeJS.Timeout;
const localStoredEmails:{[k:string]:any} = {}
export const getStoredEmail = (uid:string) => (
    localStoredEmails[uid] ?? readAdmin(`emails/${uid}`).then(x => x[0])
)

const counts:{[k:string]:number|undefined} ={}

export const saveEmail = (
    socket:Socket,
    uid:string,
    {
        emails,
        groups,
        html,
        subject,
        users
    }:{groups?:string[], 
    users?:string[],
    emails?:string[],
    subject?:string,
    html?:string}
) => {
    const obj = {
        groups,
        users,
        emails,
        subject,
        html
    }
    globalSocket.emit(
        `notifications:${uid}:email`,
        socket.id,
        obj
        )
    localStoredEmails[uid] = obj
    const thisCount =(counts[uid] ?? 0) +  1 
    counts[uid] = thisCount
    const write = () => writeAdmin(`emails/${uid}`, {
        groups: groups ?? null,
        users: users ?? null,
        emails: emails ?? null,
        subject: subject ?? null,
        html: html ?? null
    })
    if(thisCount % 200 === 0) write();
    clearTimeout(timeout)
    timeout = setTimeout(write, 15000)
}